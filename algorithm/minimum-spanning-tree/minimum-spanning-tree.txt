신장트리
1. Spanning Tree 또는 신장트리라고 부름
2. 원래의 그래프의 모든 노드가 연결되어 있으면서 트리의 속성을 만족하는 그래프

조건
1. 본래의 그래프의 모든 노드를 포함해야 함
2. 모든 노드가 서로 연결
3. 트리의 속성을 만족시킴 (사이클이 없음)

최소신장트리
1. Minimum Spanning Tree 라고 부름
2. 가능한 Spanning Tree 중에서 간선의 가중치 합이 최소인 Spanning Tree 를 지칭

신장트리 자체가 원래 그래프에서 모든 노드를 골라 조합해서 만드는 것

네비게이션 등에서 사용

대표적인 최소 신장트리 알고리즘
1. Kruskal
2. Prim

Kruskal 알고리즘
1. 모든 정점을 독립적인 집합으로 만든다.
2. 모든 간선을 비용을 기준으로 정렬하고, 비용이 작은 간선부터 양 끝의 두 정점을 비교한다.
3. 두 정점의 최상위 정점을 확인하고, 서로 다를 경우 두 정점을 연결한다. (사이클이 생기지 않도록 하는 것)
-> 그리디 알고리즘을 기반으로 동작함

3번에서 사이클이 생기는 지 판단하는 법 -> Union Find 알고리즘

    Union Find 알고리즘
    1. Disjoint Set 을 표현할 때 사용하는 알고리즘으로 트리 구조를 활용하는 알고리즘
    2. 노드들 중에 연결된 노드를 찾거나 서로 연결할 때 (합칠 때) 사용
    -> Disjoint Set
        1. 서로 중복되지 않는 부분 집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조
        2. 공통 원소가 없는 (서로소) 상호 배타적인 부분 집합들로 나눠진 원소들에 대한 자료구조를 의미
        3. Disjoint Set: 서로소 집합 자료구조

        알고리즘 상세
        1. 초기화 -> O(V)
            n 개의 원소가 개별 집합으로 이뤄지도록 초기화
        2. 정렬 -> O(ElogE)
            모든 간선을 비용을 기준으로 정렬
        3. Union -> O(1)
            두 개별 집합을 하나의 집합으로 합침, 두 트리를 하나의 트리로 만듦
            일반 트리(Linked List 구현)로 만들게 되면 O(n) 이 걸리므로
            Union-By-Rank 으로 O(logN) 으로 낮춰야 함
        4. Find -> O(1)
            여러 노드가 존재할 때 두 개의 노드를 선택해서 현재 두 노드가 서로 같은 그래프에 속하는 지 판별하기 위해 각 그룹의 최상단 원소(루트 노드)를 확인
            Path-Compression 으로 관리해 루트노드에 접근하는 시간을 단축

        -> 최종 시간복잡도: O(ElogE)

Prim 알고리즘
1. 임의의 정점을 선택 후 연결된 노드 집합에 삽입
2. 선택된 정점에 연결된 간선들을 간선 리스트에 삽입
3. 간선 리스트에서 최소 가중치를 가지는 간선부터 추출
    1. 해당 간선에 연결된 인접 정점이 연결된 노드 집합에 이미 들어있다면 스킵(사이클 방지)
    2. 아니라면 해당 간선을 선택하고 해당 간선 정보를 최소 신장 트리에 삽입
4. 추출한 간선은 간선 리스트에서 제거
5. 간선 리스트에 더 이상의 간선이 없을 때까지 3~4번 반복

- 시작 정점을 선택한 후 정점에 인접한 간선 중 최소 간선으로 연결된 정점을 선택하고 해당 정점에서 다시 최소 간선으로 연결된 정점을 선택하는
방식으로 최소 신장 트리를 확장해가는 방식
- Kruskal 은 가중치가 작은 간선부터 선택하는 것에 반에 Prim 은 특정 정점에서 시작하여 해당 정점에 연결된 가장 가중치가 작은 간선을 선택
간선으로 연결된 간선 중에서 가장 가중치가 작은 간선을 택하는 방식으로 MST 를 구함
-> 그리디 알고리즘을 기반으로 동작함

    -> 최종 시간복잡도
        최악의 경우 while 에서 모든 간선에 대해 반복하여 최소 힙에 들어가는 경우로 O(ElogE)
